/**
 * APR Calculation Utilities
 *
 * Pure functions for calculating prospective APR from pool fee data
 */

import { getTokenAmountsFromLiquidity } from "./uniswap-v3/liquidity";

interface PoolFeeData {
    feeTier: string;
    poolLiquidity: string; // BigInt as string
    token0: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
    token1: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
}

interface AprCalculationResult {
    dailyFeesToken0: bigint;
    dailyFeesToken1: bigint;
    userSharePercent: number;
    userFeesToken0: bigint;
    userFeesToken1: bigint;
    userFeesQuoteValue: bigint;
    positionValueQuote: bigint;
    dailyApr: number;
    annualizedApr: number;
}

/**
 * Calculate prospective APR for a Uniswap V3 position
 * @param poolFeeData Pool fee and volume data from subgraph
 * @param userLiquidity User's liquidity amount (BigInt)
 * @param currentTick Current pool tick
 * @param tickLower Lower tick of the position range
 * @param tickUpper Upper tick of the position range
 * @param baseTokenAddress Address of the base token
 * @param quoteTokenAddress Address of the quote token
 * @returns APR calculation breakdown
 */
export function calculateProspectiveApr(
    poolFeeData: PoolFeeData,
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number
): AprCalculationResult {
    // Parse fee tier (e.g., "500" = 0.05% = 500 / 1000000)
    const feeTierBips = BigInt(poolFeeData.feeTier);
    const FEE_DENOMINATOR = 1000000n;

    // Parse pool data (liquidity is now correctly not scaled by 18 decimals)
    const poolLiquidity = BigInt(poolFeeData.poolLiquidity);
    const token0Volume = BigInt(poolFeeData.token0.dailyVolume);
    const token1Volume = BigInt(poolFeeData.token1.dailyVolume);

    // Calculate total daily fees generated by the pool
    const dailyFeesToken0 = (token0Volume * feeTierBips) / FEE_DENOMINATOR;
    const dailyFeesToken1 = (token1Volume * feeTierBips) / FEE_DENOMINATOR;

    // Calculate user's share of the pool
    // User share = user_liquidity / (pool_liquidity + user_liquidity)
    const totalLiquidity = poolLiquidity + userLiquidity;
    const userSharePercent =
        userLiquidity === 0n
            ? 0
            : Number((userLiquidity * 10000n) / totalLiquidity) / 100; // Convert to percentage

    // Calculate user's portion of daily fees
    const userFeesToken0 = (dailyFeesToken0 * userLiquidity) / totalLiquidity;
    const userFeesToken1 = (dailyFeesToken1 * userLiquidity) / totalLiquidity;

    // Convert fees to quote token value (simplified)
    const userFeesQuoteValue = calculateFeesInQuoteToken(
        userFeesToken0,
        userFeesToken1,
        poolFeeData
    );

    // Calculate position value in quote token using actual token amounts
    const positionValueQuote = calculatePositionValueInQuoteToken(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper,
        poolFeeData
    );

    // Calculate APR
    // Daily APR = (daily_fees_quote / position_value_quote) * 100
    // Annual APR = daily_apr * 365
    const dailyApr =
        positionValueQuote === 0n
            ? 0
            : Number((userFeesQuoteValue * 10000n) / positionValueQuote) / 100;

    const annualizedApr = dailyApr * 365;

    return {
        dailyFeesToken0,
        dailyFeesToken1,
        userSharePercent,
        userFeesToken0,
        userFeesToken1,
        userFeesQuoteValue,
        positionValueQuote,
        dailyApr,
        annualizedApr,
    };
}

/**
 * Convert token fees to quote token value using actual pool prices
 */
function calculateFeesInQuoteToken(
    feesToken0: bigint,
    feesToken1: bigint,
    poolFeeData: PoolFeeData
): bigint {
    // Use actual price data from the pool
    // token0Price is the price of token0 in terms of token1 (scaled by token1 decimals)
    const token0Price = BigInt(poolFeeData.token0.price); // token0 price in token1 units
    const token1Decimals = BigInt(poolFeeData.token1.decimals);

    // Convert token0 fees to token1 equivalent
    // feesToken0 * token0Price / (10 ** token1Decimals) gives token0 fees in token1 units
    const token0FeesInToken1 = (feesToken0 * token0Price) / (10n ** token1Decimals);

    // token1 fees are already in token1 units
    const token1FeesInToken1 = feesToken1;

    // Return total fees in token1 (quote token) units
    return token0FeesInToken1 + token1FeesInToken1;
}

/**
 * Calculate position value in quote token terms using actual token amounts and pool prices
 */
function calculatePositionValueInQuoteToken(
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number,
    poolFeeData: PoolFeeData
): bigint {
    // Get actual token amounts from liquidity
    const { token0Amount, token1Amount } = getTokenAmountsFromLiquidity(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper
    );

    // Use actual price data from the pool
    const token0Price = BigInt(poolFeeData.token0.price); // token0 price in token1 units
    const token1Decimals = BigInt(poolFeeData.token1.decimals);

    // Convert token0 amount to token1 equivalent using actual pool price
    const token0ValueInToken1 = (token0Amount * token0Price) / (10n ** token1Decimals);

    // token1 amount is already in token1 units
    const token1ValueInToken1 = token1Amount;

    // Return total position value in token1 (quote token) units
    return token0ValueInToken1 + token1ValueInToken1;
}
