/**
 * APR Calculation Utilities
 *
 * Pure functions for calculating prospective APR from pool fee data
 */

import { getTokenAmountsFromLiquidity } from "./uniswap-v3/liquidity";

interface PoolFeeData {
    feeTier: string;
    poolLiquidity: string; // BigInt as string
    token0: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
    token1: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
}

interface AprCalculationResult {
    dailyFeesToken0: bigint;
    dailyFeesToken1: bigint;
    userSharePercent: number;
    userFeesToken0: bigint;
    userFeesToken1: bigint;
    userFeesQuoteValue: bigint;
    positionValueQuote: bigint;
    dailyApr: number;
    annualizedApr: number;
}

/**
 * Calculate prospective APR for a Uniswap V3 position
 * @param poolFeeData Pool fee and volume data from subgraph
 * @param userLiquidity User's liquidity amount (BigInt)
 * @param currentTick Current pool tick
 * @param tickLower Lower tick of the position range
 * @param tickUpper Upper tick of the position range
 * @param baseTokenAddress Address of the base token
 * @param quoteTokenAddress Address of the quote token
 * @returns APR calculation breakdown
 */
export function calculateProspectiveApr(
    poolFeeData: PoolFeeData,
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number
): AprCalculationResult {
    // Parse fee tier (e.g., "500" = 0.05% = 500 / 1000000)
    const feeTierBips = BigInt(poolFeeData.feeTier);
    const FEE_DENOMINATOR = 1000000n;

    // Parse pool data (liquidity is now correctly not scaled by 18 decimals)
    const poolLiquidity = BigInt(poolFeeData.poolLiquidity);
    const token0Volume = BigInt(poolFeeData.token0.dailyVolume);
    const token1Volume = BigInt(poolFeeData.token1.dailyVolume);

    // Calculate total daily fees generated by the pool
    const dailyFeesToken0 = (token0Volume * feeTierBips) / FEE_DENOMINATOR;
    const dailyFeesToken1 = (token1Volume * feeTierBips) / FEE_DENOMINATOR;

    // Calculate user's share of the pool
    // User share = user_liquidity / (pool_liquidity + user_liquidity)
    const totalLiquidity = poolLiquidity + userLiquidity;
    const userSharePercent =
        userLiquidity === 0n
            ? 0
            : Number((userLiquidity * 10000n) / totalLiquidity) / 100; // Convert to percentage

    // Calculate user's portion of daily fees
    const userFeesToken0 = (dailyFeesToken0 * userLiquidity) / totalLiquidity;
    const userFeesToken1 = (dailyFeesToken1 * userLiquidity) / totalLiquidity;

    // Convert fees to quote token value (simplified)
    const userFeesQuoteValue = calculateFeesInQuoteToken(
        userFeesToken0,
        userFeesToken1,
        poolFeeData
    );

    // Calculate position value in quote token using actual token amounts
    const positionValueQuote = calculatePositionValueInQuoteToken(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper,
        poolFeeData
    );

    // Calculate APR
    // Daily APR = (daily_fees_quote / position_value_quote) * 100
    // Annual APR = daily_apr * 365
    const dailyApr =
        positionValueQuote === 0n
            ? 0
            : Number((userFeesQuoteValue * 10000n) / positionValueQuote) / 100;

    const annualizedApr = dailyApr * 365;

    return {
        dailyFeesToken0,
        dailyFeesToken1,
        userSharePercent,
        userFeesToken0,
        userFeesToken1,
        userFeesQuoteValue,
        positionValueQuote,
        dailyApr,
        annualizedApr,
    };
}

/**
 * Convert token fees to quote token value (simplified approach)
 */
function calculateFeesInQuoteToken(
    feesToken0: bigint,
    feesToken1: bigint,
    poolFeeData: PoolFeeData
): bigint {
    // For WETH/USDC pools, we'll use a simplified approach
    // Convert both token fees to USD equivalent and sum them

    // Rough price conversions (this is simplified)
    // Token0 (WETH) ≈ $4000, Token1 (USDC) ≈ $1
    const WETH_PRICE_USD = 4000n;
    const USDC_PRICE_USD = 1n;

    // Convert token0 (WETH) fees to USD value
    const token0FeesUSD =
        (feesToken0 * WETH_PRICE_USD) /
        10n ** BigInt(poolFeeData.token0.decimals);

    // Convert token1 (USDC) fees to USD value
    const token1FeesUSD =
        (feesToken1 * USDC_PRICE_USD) /
        10n ** BigInt(poolFeeData.token1.decimals);

    // Return total in USDC units (6 decimals)
    return (token0FeesUSD + token1FeesUSD) * 10n ** 6n;
}

/**
 * Calculate position value in quote token terms using actual token amounts
 */
function calculatePositionValueInQuoteToken(
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number,
    poolFeeData: PoolFeeData
): bigint {
    // Get actual token amounts from liquidity
    const { token0Amount, token1Amount } = getTokenAmountsFromLiquidity(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper
    );

    // Convert both token amounts to USD value
    // Use simplified price conversion (in a real app, you'd get this from the pool data or price oracle)

    // For WETH/USDC pools:
    // token0 = WETH (~$4000), token1 = USDC (~$1)
    const WETH_PRICE_USD = 4000n;
    const USDC_PRICE_USD = 1n;

    // Convert token0 (WETH) to USD
    const token0ValueUSD =
        (token0Amount * WETH_PRICE_USD) /
        10n ** BigInt(poolFeeData.token0.decimals);

    // Convert token1 (USDC) to USD
    const token1ValueUSD =
        (token1Amount * USDC_PRICE_USD) /
        10n ** BigInt(poolFeeData.token1.decimals);

    // Return total value in USDC units (6 decimals)
    return (token0ValueUSD + token1ValueUSD) * 10n ** 6n;
}
