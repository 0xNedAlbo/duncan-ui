/**
 * APR Calculation Utilities
 *
 * Pure functions for calculating prospective APR from pool fee data
 */

import { getTokenAmountsFromLiquidity } from "./uniswap-v3/liquidity";
import { valueOfToken0AmountInToken1, valueOfToken1AmountInToken0 } from "./uniswap-v3/price";

interface PoolFeeData {
    feeTier: string;
    poolLiquidity: string; // BigInt as string
    sqrtPriceX96: string; // BigInt as string - current pool price as sqrt(price) * 2^96
    token0: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
    token1: {
        symbol: string;
        decimals: number;
        dailyVolume: string; // BigInt as string
        price: string; // BigInt as string
    };
}

interface AprCalculationResult {
    dailyFeesToken0: bigint;
    dailyFeesToken1: bigint;
    userSharePercent: number;
    userFeesToken0: bigint;
    userFeesToken1: bigint;
    userFeesQuoteValue: bigint;
    positionValueQuote: bigint;
    dailyApr: number;
    annualizedApr: number;
}

/**
 * Calculate prospective APR for a Uniswap V3 position
 * @param poolFeeData Pool fee and volume data from subgraph
 * @param userLiquidity User's liquidity amount (BigInt)
 * @param currentTick Current pool tick
 * @param tickLower Lower tick of the position range
 * @param tickUpper Upper tick of the position range
 * @param baseTokenAddress Address of the base token
 * @param quoteTokenAddress Address of the quote token
 * @returns APR calculation breakdown
 */
export function calculateProspectiveApr(
    poolFeeData: PoolFeeData,
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number,
    isToken0Base: boolean
): AprCalculationResult {
    // Parse fee tier (e.g., "500" = 0.05% = 500 / 1000000)
    const feeTierBips = BigInt(poolFeeData.feeTier);
    const FEE_DENOMINATOR = 1000000n;

    // Parse pool data (liquidity is now correctly not scaled by 18 decimals)
    const poolLiquidity = BigInt(poolFeeData.poolLiquidity);
    const token0Volume = BigInt(poolFeeData.token0.dailyVolume);
    const token1Volume = BigInt(poolFeeData.token1.dailyVolume);

    // Calculate total daily fees generated by the pool
    const dailyFeesToken0 = (token0Volume * feeTierBips) / FEE_DENOMINATOR;
    const dailyFeesToken1 = (token1Volume * feeTierBips) / FEE_DENOMINATOR;

    // Calculate user's share of the pool
    // User share = user_liquidity / (pool_liquidity + user_liquidity)
    const totalLiquidity = poolLiquidity + userLiquidity;
    const userSharePercent =
        userLiquidity === 0n
            ? 0
            : Number((userLiquidity * 10000n) / totalLiquidity) / 100; // Convert to percentage

    // Calculate user's portion of daily fees
    const userFeesToken0 = (dailyFeesToken0 * userLiquidity) / totalLiquidity;
    const userFeesToken1 = (dailyFeesToken1 * userLiquidity) / totalLiquidity;

    // Convert fees to quote token value with correct token role
    const isToken0Quote = !isToken0Base;
    const userFeesQuoteValue = calculateFeesInQuoteToken(
        userFeesToken0,
        userFeesToken1,
        poolFeeData,
        isToken0Quote
    );

    // Calculate position value in quote token using actual token amounts
    const positionValueQuote = calculatePositionValueInQuoteToken(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper,
        poolFeeData,
        isToken0Quote
    );

    // Calculate APR
    // Daily APR = (daily_fees_quote / position_value_quote) * 100
    // Annual APR = daily_apr * 365
    const dailyApr =
        positionValueQuote === 0n
            ? 0
            : Number((userFeesQuoteValue * 10000n) / positionValueQuote) / 100;

    const annualizedApr = dailyApr * 365;

    return {
        dailyFeesToken0,
        dailyFeesToken1,
        userSharePercent,
        userFeesToken0,
        userFeesToken1,
        userFeesQuoteValue,
        positionValueQuote,
        dailyApr,
        annualizedApr,
    };
}

/**
 * Convert token fees to quote token value using actual pool prices
 */
function calculateFeesInQuoteToken(
    feesToken0: bigint,
    feesToken1: bigint,
    poolFeeData: PoolFeeData,
    isToken0Quote: boolean
): bigint {
    const sqrtPriceX96 = BigInt(poolFeeData.sqrtPriceX96);

    if (isToken0Quote) {
        // Quote token is token0, so convert token1 fees to token0 units
        const token1FeesInToken0 = valueOfToken1AmountInToken0(feesToken1, sqrtPriceX96);

        // token0 fees are already in token0 (quote) units
        return feesToken0 + token1FeesInToken0;
    } else {
        // Quote token is token1, so convert token0 fees to token1 units
        const token0FeesInToken1 = valueOfToken0AmountInToken1(feesToken0, sqrtPriceX96);

        // token1 fees are already in token1 (quote) units
        return token0FeesInToken1 + feesToken1;
    }
}

/**
 * Calculate position value in quote token terms using actual token amounts and pool prices
 */
function calculatePositionValueInQuoteToken(
    userLiquidity: bigint,
    currentTick: number,
    tickLower: number,
    tickUpper: number,
    poolFeeData: PoolFeeData,
    isToken0Quote: boolean
): bigint {
    // Get actual token amounts from liquidity
    const { token0Amount, token1Amount } = getTokenAmountsFromLiquidity(
        userLiquidity,
        currentTick,
        tickLower,
        tickUpper
    );

    const sqrtPriceX96 = BigInt(poolFeeData.sqrtPriceX96);

    if (isToken0Quote) {
        // Quote token is token0, so convert token1 amount to token0 units
        const token1ValueInToken0 = valueOfToken1AmountInToken0(token1Amount, sqrtPriceX96);

        // token0 amount is already in token0 (quote) units
        return token0Amount + token1ValueInToken0;
    } else {
        // Quote token is token1, so convert token0 amount to token1 units
        const token0ValueInToken1 = valueOfToken0AmountInToken1(token0Amount, sqrtPriceX96);

        // token1 amount is already in token1 (quote) units
        return token0ValueInToken1 + token1Amount;
    }
}
